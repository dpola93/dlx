\title{DLX }


\documentclass[12pt]{article}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage[export]{adjustbox}
\setlength{\parindent}{0pt}
\begin{document}
\maketitle


\section{Introduction}
The goal of this project is to implement a completely functional DLX processor in RTL VHDL, simulate it and then proceed with the design flow with synthesis and layout phases.
DLX processor architecture was designed by John L. Hennessy and David A. Patterson and very well described and documented all over the internet.
This project is developed for the course Microelectronic Systems taught by Prof. Mariagrazia Graziano in Politecnico di Torino.



\paragraph{Outline}
The remainder of this article is organized as follows. 
I will first give a brief overview of the DLX architecture and my personal implementation in Section~\ref{Overview}.
In Section~\ref{Design} will go into details regarding particular aspects of the datapath and control unit.
Section~\ref{Design} and~\ref{Layout} are about the environment and results of design and layout phases.
Finally, Section~\ref{Conclusions} gives the conclusions and possible future work.

\section{Implmentation Overview}\label{Overview}
DLX is a classical 5-stage pipelined processor, with fixed length instructions and in-order execution.
Most information regarding the ISA, structure and description of operations can be found in BLABLALBLALBLAA.
\paragraph{Instructions}
In this version, all I-TYPE and R-TYPE operations have been implemented with the exception of: LHI, RFE, TRAP, ITLB, LB, LH, LBU, LHU, LF, LD, SB, SH, SF, SD and all MOV operations.
The only F-TYPE instructions implemented are MULT and MULTU, but they operate on integer register instead of floating point ones.

During normal conditions, all operations take exactly 5 cycles to execute, with the exception of multiplications, which require a fixed amount of 13 cycles (9 cycles are spent in the execute stage) and they're not pipelineable.
\paragraph{Jump and branch}
Jump and Branch instructions target address is aggressively evaluated in the decode stage in order to have less cc penalty.
In addition to this, a 2-bit predictor scheme has been implemented. This will be discussed more in the next section.
\paragraph{Control logic}
The execution is regulated by an hardwired CU, in charge of producing control words for each stage of the pipeline, as well as stall signals to stop the execution when needed.
All possible hazards have been solved through a forwarding logic, when this is not enough, a stall is sent from the control unit.
\paragraph{Memories}
Two separated memories for instruction and data have been included in the design, but they're actually not part of it because they are always external peripherals.
\begin{itemize}
\item Instruction memory is asynchronous, with 1 read port. Write is not possible.
\item Data memory is synchronous, with 1 read port and 1 write port. Concurrent write or read is not possible.
\end{itemize}
\paragraph{Register file}
Register file has 2 read port and one write port. Concurrent write and read on the same register produces a redirection of the input data to the output.
Due to the position of the register file and the moment in which the control world is computed, it is not possible to selectively enable or disable read ports because it is not known a priori whether the instruction needs one or two source register.

\section{Design Architecture}\label{Design}
As previously mentioned, the processor is described in VHDL. Most blocks are written in a structural approach up to very basic logic elements such as multiplexers, half adders, etc \ldots

An overview of the processor architecture is shown in FIGUREXXX

In the next sections we are going to see in details each single component.

\subsection{Fetch Block}
\begin{figure}[h!]
	\includegraphics[center]{images/FETCH_BLOCK.eps}
	\caption{FETCHBLOCK}
	\label{FETCHBLOCK}
\end{figure}
Fetch block is in charge of correctly fetch the instruction to be executed from the memory. This block is tightly coupled with branch predictor. As can be seen in the picture, the actual decision of the next PC to drive comes from the BTB in case of normal operations.

MUXTARGET computes the correct target pc, which is sent to the branch predictor to evaluate the misprediction signal that controls MUXPRED.
When misprediction signal is triggered, the current operation in the PC is not sent to decode stage, and it is replaced by the correct one on the successive clock cycle.

\subsection{Branch Predictor}
As previously stated, a branch predictor scheme have been applied, in particular it is a 2bit saturating counter BHT, also widely known in literature as (0,2). In addition, we have also implemented a BTB in charge of storing the PC of the next instruction in case the branch is taken.

The design applied is very generic, so the number of entries is easily configurable.

In normal situations the lowest part of the PC, called TAG, is used to index the BTH, if the instruction is recognized as a taken branch, then the PC found inside the BTB is sent to the fetch block. On the successive clock cycle, when the decode block actually computed the correct behavior of the branch, the value of the BTH is updated and, if the prediction was not correct, mispredict signal is triggered.
Also, due to the fact that mispredict signal actually cause the current operation in the fetch stage to be re-evaluated, the branch predictor automatically disables itself on the following clock cycle to avoid deadlock conditions.

Some information regarding the operations performed on the last clock cycle need to be stored, to do so, 4 have been added, they store: prediction, prediction target, TAG and mispredict signals.

\subsection{Decode Block}
\begin{figure}[h!]
	\includegraphics[center]{images/DECODE_BLOCK.eps}
	\caption{DECODEBLOCK}
	\label{DECODEBLOCK}
\end{figure}
Decode block is in charge of 4 main functions:
\begin{itemize}
	\item Split from IR register number values rA, rB and rC used in the next stage and for forwarding.
	\item Extend the immediate to 16/26 bits, either signed or unsigned, according to the current decoded instruction.
	\item Compute the addition between NPCF and the offset given by the extended immediate value
	\item Evaluate branch output through the zero comparator, the negation of this signal is also sent to other components in the system.
\end{itemize}
In case of Jump operations with link ( JAL and JALR ) the immediate value is replaced by the return address by MUXLINK.

\subsection{Execute Block}
Execute block is third stage of the pipeline. Most of the computation done here is due to the ALU which will be explored in detail in the next section.

For the moment let's forget about forwarding multiplexers, as they are going to be described later.

Alu is fed with two operands: one is always A, while the other could come wither from B or IMM, depending on the type of operation. A multiplexer is then added to achieve this functionality.
The multiplexed value is also sent directly to output, it is going to feed the Data memory input in the next stage.

Another multiplexer (DESTMUX) is also used to select in which destination register the current operation is going to write. Again, there is difference between I-TYPE and R-TYPE operations, and also a special input is due to JAL and JALR instructions that have R31 as a forced destination register.

 
\subsection{ALU and Multiplier}
The ALU is responsible for all data manipulation in our processor.

It takes as input two 32 bit operands and a special code that specify the type of operation that is going to be performed.
The output consist in the 32 bit result and a signal that is at logic '1' during multi cycle operations.

Carry out has been suppressed because in this architecture is never used.

The ALU is composed of the following units:

\begin{itemize}
	\item A single shared adder
	\item Multiplication logic
	\item Logic Unit
	\item Comparator
	\item Shifter
\end{itemize}

The results coming from these units is then multiplexed to the final output.
We are going to see in details each of them in the next sections.

\subsubsection{Shared Adder}
The adder ( used also for substractions ) is a 32-bit Pentium 4 adder.
The adder is composed of two main block: the sparse tree is in charge of computing all carries in a parallel fashion. In our case it is a radix-2 carry-merge tree and generates every fourth carry. This design is performance oriented.

The sum generator block is then based on carry select adders, which compute both results in case the carry is 0 and in case the carry is 1. These two addition are independent from the actual carry, so they can be performed in parallel. When the carry reaches the sum generator it controls a multiplexer that is used to select one of the two possible outputs.

As a consequence, the delay due to carry propagation is strongly reduced.
\subsubsection{Multiplier Logic}
As briefly introduced, Multiplication is performed by the shared P4 adder in an iterative way.
The entire procedure is based on the Booth's multiplier. Instead of producing all the sums in parallel, we compute one each clock cycle.

The flow is as follows:
At the first clock cycle all the Booth's encoding is done and sent in a PISO register. Actually the first value is already sent to the multiplexer to have a sum in the first cycle too.

Then at each clock cycle the adder takes as input the correctly shifted input value and the result of the previous addition stored in the accumulator register.
To have both signed and unsigned multiplication, a correction stage needs to be performed at the end, as can be seen in the picture, the last encoder takes this into account.

This design should be able to reduce critical paths flowing to a parallel multiplier and saving area as well.
\subsubsection{Logic Unit}
The DLX architecture supports only 3 type of logical operations: AND, OR, XOR. 
Due to this simple behavior, we decided to avoid using particular logic unit schemes.
The three operations are executed in parallel and then a multiplexer selects the correct one. 
As can be see in the picture, the schematic is pretty straightforward.

\subsubsection{Comparator}
From the ISA we need to implement several comparison operation: $(<, >, \leq, \geq, =, \neq)$.
It is able to deal with both signed and unsigned numbers.

It requires at input the difference between the two numbers, provided by the shared ALU (SUM), the carry out of the operation (C), the overflow bit (V) and the sign.

Then zero bit (Z) is computed through nor reduction and (N) is the sign of SUM.

With these values is easy to compute the possible comparisons.

There might be some redundancy in the design, we left possible optimizations to the synthesizer.

\subsubsection{Shifter}
FALLO STO CAZZO DI SHIFTER MALEDETTO

\subsection{Memory Block}
NOTHING MUCH TO SAY: ADDRESS ALWAYS COMES FROM ALU, DATA ALWAYS FROM S
MUX TO IGNORE MEMORY
NOT ENABLED WHEN NOT NEEDED

\subsection{Forwarding Logic}
Forwarding Logic is the block responsible of managing forwarding in the pipeline. It is able to detect RAW hazards and control forwarding multiplexers in decode and execute stage.

The computation is pretty simple, for each operation in EXE,MEM, and WB stage we save whether is going to write in the register file (S\_WB) and the destination register.


\subsection{Control Unit}
The control unit (CU) is in charge of generate and distribute control signal across the entire DLX pipeline.
In this design, the control unit follows an Hardwired scheme, so at each IR input a kind of memory containing a control work for each instruction is looked up.

When a signal needs to be used later in the execution, it is propagated trough a series of flip flops.

The CU is able to correctly generate and handle stall conditions due to hazards or multi cycle operations. In general, when a stage is stalled, the same goes fol the preceding stages in the pipeline, while the successive need to continue the execution. When a stage would be empty, a BUBBLE operation is inserted: a BUBBLE has the same control word as a NOP.
HARDWIRED
INDEXING
MOSTLY BEHAVIORAL
STALL HANDLING WITH BUBBLES
CONTROL WORD SIGNAL DESCRIPTION
\paragraph{S\_MUX\_PC\_BUS - (1,2)}
\paragraph{S\_EXT - (3)}
\paragraph{S\_EXT\_SIGN - (4)}
\paragraph{S\_EQ\_NEQ - (5)}
\paragraph{S\_MUX\_LINK - (6)}
\paragraph{S\_MUX\_ALUIN - (7)}
\paragraph{S\_MUX\_DEST - (8,9)}
\paragraph{S\_MUX\_MEM - (12)}
\paragraph{S\_MEM\_W\_R - (11)}
\paragraph{S\_MEM\_EN - (10)}
\paragraph{S\_RF\_W - (13)}

\subsection{Stall Logic}
LIST STALL CASES ( HAZARDS )
Control Hazards: MISPREDICTION
Data hazards: RAW only:
MEM/EXE solved by FW
WB/EXE solved by FW
DEC/EXE solved by stall: Branch or Jr situation

STALL COMING FROM EXECUTE
Structural hazard: Multiplication multi cycle operation

\subsection{Instruction and Data Memories}
INSTRUCTION AND DATA MEMORIES NOT PART OF THE DESIGN ITSELF, SIZE OF DMEM AND IMEM
As previously stated, both memories are not part of the design itself.
Imem is accessed during fetch operation, no enable port because we need to fetch an operation at each clock cycle.
Dmem accesses during MEM stage. There is an enable signal and a W/R. both read and write are synchronous during the falling edge of the clock. to move it at the rising edge need to move the control signal before, so new values are ready at the clock edge.


\section{Simulation and Test}\label{Conclusions}
The simulation environment is composed as follows:
A test bench file: tb\_top\_level instantiates the dlx and the two memories and provides clock and reset signals to all the components.

Then there is a compiler Perl/Bash script that takes as input a dlx assembly code and compiles it into a memory dump ready to be loaded by both memories.
This script, which has been provided us have a bug: when two or more consecutive operations are exactly identical, only one is translated to binary code, while the other are simply empty lines.

We have also created a wave generation script (WABE\_BASIC.do) to be loaded directly into vsim that select the basic waveforms to be visualized.

Testing an entire processor is not an easy task, due to the very large possible combinations of instructions.
On the very early stages of the design, testing was mainly done block by block in a bottom up fashion. for example, for the ALU, first we tested each single component such as comparator and shifter, then we integrated them one at a time and checked it.

An approach like this has been used until we reached the entire dlx block.
Then we moved into running test programs, starting from very basic ones to test each single operation, and then trying different combinations of hazards, forwarding, multi cycle operations and branch predictions.

For a final test, we ran a quicksort algorithm.

  

\section{Synthesis}\label{Synthesis}
Not simple. separated CU and datapath.
ST 65nm library. not suitable to synthesized memories, problems on BTB due to high number of lines. reduced to 8 lines for synthesis. 
all-flatten and compile ultra option gives extraordinary results but doesnt give informations on critical path.



\section{Layout}\label{Layout}
In this section we describe the results.

\bibliographystyle{abbrv}
\bibliography{main}

\end{document}